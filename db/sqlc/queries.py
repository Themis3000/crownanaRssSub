# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.29.0
# source: queries.sql
import datetime
from typing import Iterator, Optional

import sqlalchemy

from . import models


ADD_SUBSCRIBER = """-- name: add_subscriber \\:one
INSERT INTO subscriptions (feed_id, email)
VALUES (:p1, :p2)
returning subscriber_id, feed_id, subscription_time, confirmation_code, email, signup_confirmed
"""


CONFIRM_SUBSCRIPTION = """-- name: confirm_subscription \\:exec
UPDATE subscriptions
    set signup_confirmed = TRUE
WHERE subscriber_id = :p1
"""


CREATE_FEED = """-- name: create_feed \\:one
INSERT INTO feeds (rss_url, feed_name, last_post_id, last_post_pub)
VALUES (:p1, :p2, :p3, :p4)
RETURNING feed_id, rss_url, feed_name, addition_date, interval, last_completed, last_update, last_post_id, last_post_pub, next_run
"""


GET_FEED = """-- name: get_feed \\:one
SELECT feed_id, rss_url, feed_name, addition_date, interval, last_completed, last_update, last_post_id, last_post_pub, next_run from feeds
WHERE feed_id = :p1 LIMIT 1
"""


GET_FEED_BY_RSS = """-- name: get_feed_by_rss \\:one
SELECT feed_id, rss_url, feed_name, addition_date, interval, last_completed, last_update, last_post_id, last_post_pub, next_run from feeds
WHERE rss_url = :p1 LIMIT 1
"""


GET_SUBSCRIBER = """-- name: get_subscriber \\:one
SELECT subscriber_id, feed_id, subscription_time, confirmation_code, email, signup_confirmed from subscriptions
WHERE subscriber_id = :p1 LIMIT 1
"""


LIST_FEEDS = """-- name: list_feeds \\:many
SELECT feed_id, rss_url, feed_name, addition_date, interval, last_completed, last_update, last_post_id, last_post_pub, next_run from feeds
ORDER BY feed_id
"""


SET_LAST_CHECK_NOW = """-- name: set_last_check_now \\:exec
UPDATE feeds
    set last_update = NOW()
WHERE feed_id = :p1
"""


UPDATE_POST = """-- name: update_post \\:exec
UPDATE feeds
    set last_post_id = :p2,
    last_post_pub = :p3,
    last_update = :p4,
    last_completed = :p4
WHERE feed_id = :p1
"""


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def add_subscriber(self, *, feed_id: int, email: str) -> Optional[models.Subscription]:
        row = self._conn.execute(sqlalchemy.text(ADD_SUBSCRIBER), {"p1": feed_id, "p2": email}).first()
        if row is None:
            return None
        return models.Subscription(
            subscriber_id=row[0],
            feed_id=row[1],
            subscription_time=row[2],
            confirmation_code=row[3],
            email=row[4],
            signup_confirmed=row[5],
        )

    def confirm_subscription(self, *, subscriber_id: int) -> None:
        self._conn.execute(sqlalchemy.text(CONFIRM_SUBSCRIPTION), {"p1": subscriber_id})

    def create_feed(self, *, rss_url: str, feed_name: str, last_post_id: str, last_post_pub: datetime.datetime) -> Optional[models.Feed]:
        row = self._conn.execute(sqlalchemy.text(CREATE_FEED), {
            "p1": rss_url,
            "p2": feed_name,
            "p3": last_post_id,
            "p4": last_post_pub,
        }).first()
        if row is None:
            return None
        return models.Feed(
            feed_id=row[0],
            rss_url=row[1],
            feed_name=row[2],
            addition_date=row[3],
            interval=row[4],
            last_completed=row[5],
            last_update=row[6],
            last_post_id=row[7],
            last_post_pub=row[8],
            next_run=row[9],
        )

    def get_feed(self, *, feed_id: int) -> Optional[models.Feed]:
        row = self._conn.execute(sqlalchemy.text(GET_FEED), {"p1": feed_id}).first()
        if row is None:
            return None
        return models.Feed(
            feed_id=row[0],
            rss_url=row[1],
            feed_name=row[2],
            addition_date=row[3],
            interval=row[4],
            last_completed=row[5],
            last_update=row[6],
            last_post_id=row[7],
            last_post_pub=row[8],
            next_run=row[9],
        )

    def get_feed_by_rss(self, *, rss_url: str) -> Optional[models.Feed]:
        row = self._conn.execute(sqlalchemy.text(GET_FEED_BY_RSS), {"p1": rss_url}).first()
        if row is None:
            return None
        return models.Feed(
            feed_id=row[0],
            rss_url=row[1],
            feed_name=row[2],
            addition_date=row[3],
            interval=row[4],
            last_completed=row[5],
            last_update=row[6],
            last_post_id=row[7],
            last_post_pub=row[8],
            next_run=row[9],
        )

    def get_subscriber(self, *, subscriber_id: int) -> Optional[models.Subscription]:
        row = self._conn.execute(sqlalchemy.text(GET_SUBSCRIBER), {"p1": subscriber_id}).first()
        if row is None:
            return None
        return models.Subscription(
            subscriber_id=row[0],
            feed_id=row[1],
            subscription_time=row[2],
            confirmation_code=row[3],
            email=row[4],
            signup_confirmed=row[5],
        )

    def list_feeds(self) -> Iterator[models.Feed]:
        result = self._conn.execute(sqlalchemy.text(LIST_FEEDS))
        for row in result:
            yield models.Feed(
                feed_id=row[0],
                rss_url=row[1],
                feed_name=row[2],
                addition_date=row[3],
                interval=row[4],
                last_completed=row[5],
                last_update=row[6],
                last_post_id=row[7],
                last_post_pub=row[8],
                next_run=row[9],
            )

    def set_last_check_now(self, *, feed_id: int) -> None:
        self._conn.execute(sqlalchemy.text(SET_LAST_CHECK_NOW), {"p1": feed_id})

    def update_post(self, *, feed_id: int, last_post_id: str, last_post_pub: datetime.datetime, last_update: datetime.datetime) -> None:
        self._conn.execute(sqlalchemy.text(UPDATE_POST), {
            "p1": feed_id,
            "p2": last_post_id,
            "p3": last_post_pub,
            "p4": last_update,
        })
