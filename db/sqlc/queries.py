# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.29.0
# source: queries.sql
import dataclasses
import datetime
from typing import Iterator, Optional

import sqlalchemy

from . import models


ADD_FEED_HISTORY = """-- name: add_feed_history \\:exec
INSERT INTO feed_history (feed_id, title, link, post_date, unique_id)
    VALUES (:p1, :p2, :p3, :p4, :p5)
"""


@dataclasses.dataclass()
class add_feed_historyParams:
    feed_id: int
    title: str
    link: str
    post_date: datetime.datetime
    unique_id: str


ADD_SUBSCRIBER = """-- name: add_subscriber \\:one
INSERT INTO subscriptions (feed_id, email)
VALUES (:p1, :p2)
returning subscriber_id, feed_id, subscription_time, confirmation_code, email, signup_confirmed, last_post_notify, has_notification_pending
"""


CONFIRM_SUBSCRIPTION = """-- name: confirm_subscription \\:exec
UPDATE subscriptions
    set signup_confirmed = TRUE
WHERE subscriber_id = :p1
"""


CREATE_FEED = """-- name: create_feed \\:one
INSERT INTO feeds (rss_url, feed_name)
VALUES (:p1, :p2)
RETURNING feed_id, rss_url, feed_name, addition_date, interval, last_completed, consecutive_failures, next_run
"""


FEED_SET_LAST_CHECK_NOW = """-- name: feed_set_last_check_now \\:exec
UPDATE feeds
    set last_completed = NOW(),
        consecutive_failures = 0
WHERE feed_id = :p1
"""


FEED_SET_LAST_FAIL_NOW = """-- name: feed_set_last_fail_now \\:exec
UPDATE feeds
    set last_completed = NOW(),
        consecutive_failures = consecutive_failures + 1
WHERE feed_id = :p1
"""


FEED_UPDATE_NOW = """-- name: feed_update_now \\:exec
UPDATE feeds
    SET last_completed = NOW() - feeds.interval - interval '00\\:05\\:00'
WHERE rss_url = :p1
"""


GET_CURRENT_POST = """-- name: get_current_post \\:one
SELECT history_id, feed_id, title, link, post_date, collection_date, unique_id FROM feed_history
WHERE feed_id = :p1
ORDER BY post_date desc
LIMIT 1
"""


GET_FEED = """-- name: get_feed \\:one
SELECT feed_id, rss_url, feed_name, addition_date, interval, last_completed, consecutive_failures, next_run from feeds
WHERE feed_id = :p1
"""


GET_FEED_BY_RSS = """-- name: get_feed_by_rss \\:one
SELECT feed_id, rss_url, feed_name, addition_date, interval, last_completed, consecutive_failures, next_run from feeds
WHERE rss_url = :p1 LIMIT 1
"""


GET_FEED_HISTORY = """-- name: get_feed_history \\:many
SELECT history_id, feed_id, title, link, post_date, collection_date, unique_id FROM feed_history
WHERE feed_id = :p1
ORDER BY post_date desc
LIMIT COALESCE(:p2\\:\\:int, 20)
"""


GET_FEED_HISTORY_SINCE_DATE = """-- name: get_feed_history_since_date \\:many
SELECT history_id, feed_id, title, link, post_date, collection_date, unique_id FROM feed_history
WHERE feed_id = :p1 AND collection_date > :p2
ORDER BY post_date desc
LIMIT COALESCE(:p3\\:\\:int, 20)
"""


GET_FEED_TO_RUN = """-- name: get_feed_to_run \\:one
SELECT feed_id, rss_url, feed_name, addition_date, interval, last_completed, consecutive_failures, next_run from feeds
WHERE now() > next_run
LIMIT 1
FOR NO KEY UPDATE SKIP LOCKED
"""


GET_SUBSCRIBER = """-- name: get_subscriber \\:one
SELECT subscriber_id, feed_id, subscription_time, confirmation_code, email, signup_confirmed, last_post_notify, has_notification_pending from subscriptions
WHERE subscriber_id = :p1 LIMIT 1
"""


LIST_FEEDS = """-- name: list_feeds \\:many
SELECT feed_id, rss_url, feed_name, addition_date, interval, last_completed, consecutive_failures, next_run from feeds
ORDER BY feed_id
"""


MARK_FEED_UPDATES = """-- name: mark_feed_updates \\:exec
UPDATE subscriptions
    SET has_notification_pending = true
WHERE feed_id = :p1 AND signup_confirmed = true
"""


POST_ID_EXISTS = """-- name: post_id_exists \\:one
SELECT EXISTS(
    SELECT FROM feed_history
    WHERE feed_id = :p1 AND unique_id = :p2
)
"""


REMOVE_SUBSCRIPTION = """-- name: remove_subscription \\:exec
DELETE FROM subscriptions
WHERE subscriber_id = :p1
"""


SUBSCRIBER_EXISTS = """-- name: subscriber_exists \\:one
SELECT exists(SELECT subscriber_id, feed_id, subscription_time, confirmation_code, email, signup_confirmed, last_post_notify, has_notification_pending FROM subscriptions WHERE subscriber_id = :p1) AS sub_exists
"""


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def add_feed_history(self, arg: add_feed_historyParams) -> None:
        self._conn.execute(sqlalchemy.text(ADD_FEED_HISTORY), {
            "p1": arg.feed_id,
            "p2": arg.title,
            "p3": arg.link,
            "p4": arg.post_date,
            "p5": arg.unique_id,
        })

    def add_subscriber(self, *, feed_id: int, email: str) -> Optional[models.Subscription]:
        row = self._conn.execute(sqlalchemy.text(ADD_SUBSCRIBER), {"p1": feed_id, "p2": email}).first()
        if row is None:
            return None
        return models.Subscription(
            subscriber_id=row[0],
            feed_id=row[1],
            subscription_time=row[2],
            confirmation_code=row[3],
            email=row[4],
            signup_confirmed=row[5],
            last_post_notify=row[6],
            has_notification_pending=row[7],
        )

    def confirm_subscription(self, *, subscriber_id: int) -> None:
        self._conn.execute(sqlalchemy.text(CONFIRM_SUBSCRIPTION), {"p1": subscriber_id})

    def create_feed(self, *, rss_url: str, feed_name: str) -> Optional[models.Feed]:
        row = self._conn.execute(sqlalchemy.text(CREATE_FEED), {"p1": rss_url, "p2": feed_name}).first()
        if row is None:
            return None
        return models.Feed(
            feed_id=row[0],
            rss_url=row[1],
            feed_name=row[2],
            addition_date=row[3],
            interval=row[4],
            last_completed=row[5],
            consecutive_failures=row[6],
            next_run=row[7],
        )

    def feed_set_last_check_now(self, *, feed_id: int) -> None:
        self._conn.execute(sqlalchemy.text(FEED_SET_LAST_CHECK_NOW), {"p1": feed_id})

    def feed_set_last_fail_now(self, *, feed_id: int) -> None:
        self._conn.execute(sqlalchemy.text(FEED_SET_LAST_FAIL_NOW), {"p1": feed_id})

    def feed_update_now(self, *, rss_url: str) -> None:
        self._conn.execute(sqlalchemy.text(FEED_UPDATE_NOW), {"p1": rss_url})

    def get_current_post(self, *, feed_id: int) -> Optional[models.FeedHistory]:
        row = self._conn.execute(sqlalchemy.text(GET_CURRENT_POST), {"p1": feed_id}).first()
        if row is None:
            return None
        return models.FeedHistory(
            history_id=row[0],
            feed_id=row[1],
            title=row[2],
            link=row[3],
            post_date=row[4],
            collection_date=row[5],
            unique_id=row[6],
        )

    def get_feed(self, *, feed_id: int) -> Optional[models.Feed]:
        row = self._conn.execute(sqlalchemy.text(GET_FEED), {"p1": feed_id}).first()
        if row is None:
            return None
        return models.Feed(
            feed_id=row[0],
            rss_url=row[1],
            feed_name=row[2],
            addition_date=row[3],
            interval=row[4],
            last_completed=row[5],
            consecutive_failures=row[6],
            next_run=row[7],
        )

    def get_feed_by_rss(self, *, rss_url: str) -> Optional[models.Feed]:
        row = self._conn.execute(sqlalchemy.text(GET_FEED_BY_RSS), {"p1": rss_url}).first()
        if row is None:
            return None
        return models.Feed(
            feed_id=row[0],
            rss_url=row[1],
            feed_name=row[2],
            addition_date=row[3],
            interval=row[4],
            last_completed=row[5],
            consecutive_failures=row[6],
            next_run=row[7],
        )

    def get_feed_history(self, *, feed_id: int, limit: Optional[int]) -> Iterator[models.FeedHistory]:
        result = self._conn.execute(sqlalchemy.text(GET_FEED_HISTORY), {"p1": feed_id, "p2": limit})
        for row in result:
            yield models.FeedHistory(
                history_id=row[0],
                feed_id=row[1],
                title=row[2],
                link=row[3],
                post_date=row[4],
                collection_date=row[5],
                unique_id=row[6],
            )

    def get_feed_history_since_date(self, *, feed_id: int, collection_date: datetime.datetime, limit: Optional[int]) -> Iterator[models.FeedHistory]:
        result = self._conn.execute(sqlalchemy.text(GET_FEED_HISTORY_SINCE_DATE), {"p1": feed_id, "p2": collection_date, "p3": limit})
        for row in result:
            yield models.FeedHistory(
                history_id=row[0],
                feed_id=row[1],
                title=row[2],
                link=row[3],
                post_date=row[4],
                collection_date=row[5],
                unique_id=row[6],
            )

    def get_feed_to_run(self) -> Optional[models.Feed]:
        row = self._conn.execute(sqlalchemy.text(GET_FEED_TO_RUN)).first()
        if row is None:
            return None
        return models.Feed(
            feed_id=row[0],
            rss_url=row[1],
            feed_name=row[2],
            addition_date=row[3],
            interval=row[4],
            last_completed=row[5],
            consecutive_failures=row[6],
            next_run=row[7],
        )

    def get_subscriber(self, *, subscriber_id: int) -> Optional[models.Subscription]:
        row = self._conn.execute(sqlalchemy.text(GET_SUBSCRIBER), {"p1": subscriber_id}).first()
        if row is None:
            return None
        return models.Subscription(
            subscriber_id=row[0],
            feed_id=row[1],
            subscription_time=row[2],
            confirmation_code=row[3],
            email=row[4],
            signup_confirmed=row[5],
            last_post_notify=row[6],
            has_notification_pending=row[7],
        )

    def list_feeds(self) -> Iterator[models.Feed]:
        result = self._conn.execute(sqlalchemy.text(LIST_FEEDS))
        for row in result:
            yield models.Feed(
                feed_id=row[0],
                rss_url=row[1],
                feed_name=row[2],
                addition_date=row[3],
                interval=row[4],
                last_completed=row[5],
                consecutive_failures=row[6],
                next_run=row[7],
            )

    def mark_feed_updates(self, *, feed_id: int) -> None:
        self._conn.execute(sqlalchemy.text(MARK_FEED_UPDATES), {"p1": feed_id})

    def post_id_exists(self, *, feed_id: int, unique_id: str) -> Optional[bool]:
        row = self._conn.execute(sqlalchemy.text(POST_ID_EXISTS), {"p1": feed_id, "p2": unique_id}).first()
        if row is None:
            return None
        return row[0]

    def remove_subscription(self, *, subscriber_id: int) -> None:
        self._conn.execute(sqlalchemy.text(REMOVE_SUBSCRIPTION), {"p1": subscriber_id})

    def subscriber_exists(self, *, subscriber_id: int) -> Optional[bool]:
        row = self._conn.execute(sqlalchemy.text(SUBSCRIBER_EXISTS), {"p1": subscriber_id}).first()
        if row is None:
            return None
        return row[0]
