# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.29.0
# source: queries.sql
import dataclasses
import datetime
from typing import Iterator, Optional

import sqlalchemy

from . import models


ADD_FEED_HISTORY = """-- name: add_feed_history \\:exec
INSERT INTO feed_history (feed_id, title, link, post_date, unique_id)
    VALUES (:p1, :p2, :p3, :p4, :p5)
"""


@dataclasses.dataclass()
class add_feed_historyParams:
    feed_id: int
    title: str
    link: str
    post_date: datetime.datetime
    unique_id: str


ADD_SUBSCRIBER = """-- name: add_subscriber \\:one
INSERT INTO subscriptions (feed_id, email, last_post_notify)
VALUES (:p1, :p2, (
        SELECT feed_history.history_id FROM feed_history
        WHERE feed_history.feed_id = :p1
        ORDER BY post_date desc
        LIMIT 1
    ))
returning subscriber_id, feed_id, subscription_time, confirmation_code, email, signup_confirmed, last_post_notify, has_notification_pending, last_notification_time, notification_interval, next_notification, is_being_processed, last_process_update
"""


CONFIRM_SUBSCRIPTION = """-- name: confirm_subscription \\:exec
UPDATE subscriptions
    set signup_confirmed = TRUE
WHERE subscriber_id = :p1
"""


CREATE_FEED = """-- name: create_feed \\:one
INSERT INTO feeds (rss_url, feed_name)
VALUES (:p1, :p2)
RETURNING feed_id, rss_url, feed_name, addition_date, interval, last_completed, consecutive_failures, next_run
"""


FEED_SET_LAST_CHECK_NOW = """-- name: feed_set_last_check_now \\:exec
UPDATE feeds
    set last_completed = NOW(),
        consecutive_failures = 0
WHERE feed_id = :p1
"""


FEED_SET_LAST_FAIL_NOW = """-- name: feed_set_last_fail_now \\:exec
UPDATE feeds
    set last_completed = NOW(),
        consecutive_failures = consecutive_failures + 1
WHERE feed_id = :p1
"""


FEED_UPDATE_NOW = """-- name: feed_update_now \\:exec
UPDATE feeds
    SET last_completed = NOW() - feeds.interval - interval '00\\:05\\:00'
WHERE rss_url = :p1
"""


FIND_NOTIFY_MARK_UPDATING_SUBS = """-- name: find_notify_mark_updating_subs \\:many
UPDATE subscriptions
    SET is_being_processed = true,
        last_process_update = NOW()
FROM feeds
WHERE subscriber_id = (
    SELECT subscriber_id
    FROM subscriptions
    WHERE has_notification_pending = true AND
          NOW() > next_notification AND
          signup_confirmed = true AND
          (not is_being_processed OR last_process_update > NOW() + interval '00\\:05\\:00')
    ORDER BY subscriptions.feed_id
    LIMIT :p1
    FOR NO KEY UPDATE SKIP LOCKED
    ) AND
    subscriptions.feed_id = feeds.feed_id
RETURNING subscriber_id, subscriptions.feed_id, last_post_notify, email, confirmation_code, feed_name, last_process_update
"""


@dataclasses.dataclass()
class find_notify_mark_updating_subsRow:
    subscriber_id: int
    feed_id: int
    last_post_notify: int
    email: str
    confirmation_code: float
    feed_name: str
    last_process_update: datetime.datetime


GET_CURRENT_POST = """-- name: get_current_post \\:one
SELECT history_id, feed_id, title, link, post_date, collection_date, unique_id FROM feed_history
WHERE feed_id = :p1
ORDER BY post_date desc
LIMIT 1
"""


GET_FEED = """-- name: get_feed \\:one
SELECT feed_id, rss_url, feed_name, addition_date, interval, last_completed, consecutive_failures, next_run from feeds
WHERE feed_id = :p1
"""


GET_FEED_BY_RSS = """-- name: get_feed_by_rss \\:one
SELECT feed_id, rss_url, feed_name, addition_date, interval, last_completed, consecutive_failures, next_run from feeds
WHERE rss_url = :p1 LIMIT 1
"""


GET_FEED_HISTORY = """-- name: get_feed_history \\:many
SELECT history_id, feed_id, title, link, post_date, collection_date, unique_id FROM feed_history
WHERE feed_id = :p1
ORDER BY post_date desc
LIMIT :p2
"""


GET_FEED_HISTORY_SINCE_DATE = """-- name: get_feed_history_since_date \\:many
SELECT history_id, feed_id, title, link, post_date, collection_date, unique_id FROM feed_history
WHERE feed_id = :p1 AND post_date > :p2
ORDER BY post_date desc
LIMIT :p3
"""


GET_FEED_HISTORY_SINCE_ID = """-- name: get_feed_history_since_id \\:many
SELECT history_id, feed_id, title, link, post_date, collection_date, unique_id from feed_history
WHERE feed_history.feed_id = :p1 AND post_date > (
        SELECT post_date from feed_history
        WHERE feed_history.history_id = :p2
    )
ORDER BY post_date desc
LIMIT :p3
"""


GET_FEED_TO_RUN = """-- name: get_feed_to_run \\:one
SELECT feeds.feed_id, post_date, unique_id, rss_url
FROM feeds JOIN feed_history ON feeds.feed_id = feed_history.feed_id
WHERE now() > next_run
ORDER BY post_date desc
LIMIT 1
FOR NO KEY UPDATE SKIP LOCKED
"""


@dataclasses.dataclass()
class get_feed_to_runRow:
    feed_id: int
    post_date: datetime.datetime
    unique_id: str
    rss_url: str


GET_SUBSCRIBER = """-- name: get_subscriber \\:one
SELECT subscriber_id, feed_id, subscription_time, confirmation_code, email, signup_confirmed, last_post_notify, has_notification_pending, last_notification_time, notification_interval, next_notification, is_being_processed, last_process_update from subscriptions
WHERE subscriber_id = :p1 LIMIT 1
"""


LIST_FEEDS = """-- name: list_feeds \\:many
SELECT feed_id, rss_url, feed_name, addition_date, interval, last_completed, consecutive_failures, next_run from feeds
ORDER BY feed_id
"""


MARK_FEED_UPDATES = """-- name: mark_feed_updates \\:exec
UPDATE subscriptions
    SET has_notification_pending = true
WHERE feed_id = :p1 AND signup_confirmed = true
"""


MARK_SUBSCRIBER_NOTIFIED = """-- name: mark_subscriber_notified \\:exec
UPDATE subscriptions
    SET has_notification_pending = false,
        last_post_notify = :p2,
        last_notification_time = NOW(),
        is_being_processed = false
WHERE subscriber_id = :p1
"""


POST_ID_EXISTS = """-- name: post_id_exists \\:one
SELECT EXISTS(
    SELECT FROM feed_history
    WHERE feed_id = :p1 AND unique_id = :p2
)
"""


REMOVE_SUBSCRIPTION = """-- name: remove_subscription \\:exec
DELETE FROM subscriptions
WHERE subscriber_id = :p1
"""


SUB_NOTIFY_NOW = """-- name: sub_notify_now \\:exec
UPDATE subscriptions
    SET last_notification_time = NOW() - subscriptions.notification_interval - interval '00\\:05\\:00'
WHERE subscriber_id = :p1
"""


SUBSCRIBER_EXISTS = """-- name: subscriber_exists \\:one
SELECT exists(SELECT subscriber_id, feed_id, subscription_time, confirmation_code, email, signup_confirmed, last_post_notify, has_notification_pending, last_notification_time, notification_interval, next_notification, is_being_processed, last_process_update FROM subscriptions WHERE subscriber_id = :p1) AS sub_exists
"""


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def add_feed_history(self, arg: add_feed_historyParams) -> None:
        self._conn.execute(sqlalchemy.text(ADD_FEED_HISTORY), {
            "p1": arg.feed_id,
            "p2": arg.title,
            "p3": arg.link,
            "p4": arg.post_date,
            "p5": arg.unique_id,
        })

    def add_subscriber(self, *, feed_id: int, email: str) -> Optional[models.Subscription]:
        row = self._conn.execute(sqlalchemy.text(ADD_SUBSCRIBER), {"p1": feed_id, "p2": email}).first()
        if row is None:
            return None
        return models.Subscription(
            subscriber_id=row[0],
            feed_id=row[1],
            subscription_time=row[2],
            confirmation_code=row[3],
            email=row[4],
            signup_confirmed=row[5],
            last_post_notify=row[6],
            has_notification_pending=row[7],
            last_notification_time=row[8],
            notification_interval=row[9],
            next_notification=row[10],
            is_being_processed=row[11],
            last_process_update=row[12],
        )

    def confirm_subscription(self, *, subscriber_id: int) -> None:
        self._conn.execute(sqlalchemy.text(CONFIRM_SUBSCRIPTION), {"p1": subscriber_id})

    def create_feed(self, *, rss_url: str, feed_name: str) -> Optional[models.Feed]:
        row = self._conn.execute(sqlalchemy.text(CREATE_FEED), {"p1": rss_url, "p2": feed_name}).first()
        if row is None:
            return None
        return models.Feed(
            feed_id=row[0],
            rss_url=row[1],
            feed_name=row[2],
            addition_date=row[3],
            interval=row[4],
            last_completed=row[5],
            consecutive_failures=row[6],
            next_run=row[7],
        )

    def feed_set_last_check_now(self, *, feed_id: int) -> None:
        self._conn.execute(sqlalchemy.text(FEED_SET_LAST_CHECK_NOW), {"p1": feed_id})

    def feed_set_last_fail_now(self, *, feed_id: int) -> None:
        self._conn.execute(sqlalchemy.text(FEED_SET_LAST_FAIL_NOW), {"p1": feed_id})

    def feed_update_now(self, *, rss_url: str) -> None:
        self._conn.execute(sqlalchemy.text(FEED_UPDATE_NOW), {"p1": rss_url})

    def find_notify_mark_updating_subs(self, *, limit: int) -> Iterator[find_notify_mark_updating_subsRow]:
        result = self._conn.execute(sqlalchemy.text(FIND_NOTIFY_MARK_UPDATING_SUBS), {"p1": limit})
        for row in result:
            yield find_notify_mark_updating_subsRow(
                subscriber_id=row[0],
                feed_id=row[1],
                last_post_notify=row[2],
                email=row[3],
                confirmation_code=row[4],
                feed_name=row[5],
                last_process_update=row[6],
            )

    def get_current_post(self, *, feed_id: int) -> Optional[models.FeedHistory]:
        row = self._conn.execute(sqlalchemy.text(GET_CURRENT_POST), {"p1": feed_id}).first()
        if row is None:
            return None
        return models.FeedHistory(
            history_id=row[0],
            feed_id=row[1],
            title=row[2],
            link=row[3],
            post_date=row[4],
            collection_date=row[5],
            unique_id=row[6],
        )

    def get_feed(self, *, feed_id: int) -> Optional[models.Feed]:
        row = self._conn.execute(sqlalchemy.text(GET_FEED), {"p1": feed_id}).first()
        if row is None:
            return None
        return models.Feed(
            feed_id=row[0],
            rss_url=row[1],
            feed_name=row[2],
            addition_date=row[3],
            interval=row[4],
            last_completed=row[5],
            consecutive_failures=row[6],
            next_run=row[7],
        )

    def get_feed_by_rss(self, *, rss_url: str) -> Optional[models.Feed]:
        row = self._conn.execute(sqlalchemy.text(GET_FEED_BY_RSS), {"p1": rss_url}).first()
        if row is None:
            return None
        return models.Feed(
            feed_id=row[0],
            rss_url=row[1],
            feed_name=row[2],
            addition_date=row[3],
            interval=row[4],
            last_completed=row[5],
            consecutive_failures=row[6],
            next_run=row[7],
        )

    def get_feed_history(self, *, feed_id: int, limit: int) -> Iterator[models.FeedHistory]:
        result = self._conn.execute(sqlalchemy.text(GET_FEED_HISTORY), {"p1": feed_id, "p2": limit})
        for row in result:
            yield models.FeedHistory(
                history_id=row[0],
                feed_id=row[1],
                title=row[2],
                link=row[3],
                post_date=row[4],
                collection_date=row[5],
                unique_id=row[6],
            )

    def get_feed_history_since_date(self, *, feed_id: int, post_date: datetime.datetime, limit: int) -> Iterator[models.FeedHistory]:
        result = self._conn.execute(sqlalchemy.text(GET_FEED_HISTORY_SINCE_DATE), {"p1": feed_id, "p2": post_date, "p3": limit})
        for row in result:
            yield models.FeedHistory(
                history_id=row[0],
                feed_id=row[1],
                title=row[2],
                link=row[3],
                post_date=row[4],
                collection_date=row[5],
                unique_id=row[6],
            )

    def get_feed_history_since_id(self, *, feed_id: int, history_id: int, limit: int) -> Iterator[models.FeedHistory]:
        result = self._conn.execute(sqlalchemy.text(GET_FEED_HISTORY_SINCE_ID), {"p1": feed_id, "p2": history_id, "p3": limit})
        for row in result:
            yield models.FeedHistory(
                history_id=row[0],
                feed_id=row[1],
                title=row[2],
                link=row[3],
                post_date=row[4],
                collection_date=row[5],
                unique_id=row[6],
            )

    def get_feed_to_run(self) -> Optional[get_feed_to_runRow]:
        row = self._conn.execute(sqlalchemy.text(GET_FEED_TO_RUN)).first()
        if row is None:
            return None
        return get_feed_to_runRow(
            feed_id=row[0],
            post_date=row[1],
            unique_id=row[2],
            rss_url=row[3],
        )

    def get_subscriber(self, *, subscriber_id: int) -> Optional[models.Subscription]:
        row = self._conn.execute(sqlalchemy.text(GET_SUBSCRIBER), {"p1": subscriber_id}).first()
        if row is None:
            return None
        return models.Subscription(
            subscriber_id=row[0],
            feed_id=row[1],
            subscription_time=row[2],
            confirmation_code=row[3],
            email=row[4],
            signup_confirmed=row[5],
            last_post_notify=row[6],
            has_notification_pending=row[7],
            last_notification_time=row[8],
            notification_interval=row[9],
            next_notification=row[10],
            is_being_processed=row[11],
            last_process_update=row[12],
        )

    def list_feeds(self) -> Iterator[models.Feed]:
        result = self._conn.execute(sqlalchemy.text(LIST_FEEDS))
        for row in result:
            yield models.Feed(
                feed_id=row[0],
                rss_url=row[1],
                feed_name=row[2],
                addition_date=row[3],
                interval=row[4],
                last_completed=row[5],
                consecutive_failures=row[6],
                next_run=row[7],
            )

    def mark_feed_updates(self, *, feed_id: int) -> None:
        self._conn.execute(sqlalchemy.text(MARK_FEED_UPDATES), {"p1": feed_id})

    def mark_subscriber_notified(self, *, subscriber_id: int, last_post_notify: int) -> None:
        self._conn.execute(sqlalchemy.text(MARK_SUBSCRIBER_NOTIFIED), {"p1": subscriber_id, "p2": last_post_notify})

    def post_id_exists(self, *, feed_id: int, unique_id: str) -> Optional[bool]:
        row = self._conn.execute(sqlalchemy.text(POST_ID_EXISTS), {"p1": feed_id, "p2": unique_id}).first()
        if row is None:
            return None
        return row[0]

    def remove_subscription(self, *, subscriber_id: int) -> None:
        self._conn.execute(sqlalchemy.text(REMOVE_SUBSCRIPTION), {"p1": subscriber_id})

    def sub_notify_now(self, *, subscriber_id: int) -> None:
        self._conn.execute(sqlalchemy.text(SUB_NOTIFY_NOW), {"p1": subscriber_id})

    def subscriber_exists(self, *, subscriber_id: int) -> Optional[bool]:
        row = self._conn.execute(sqlalchemy.text(SUBSCRIBER_EXISTS), {"p1": subscriber_id}).first()
        if row is None:
            return None
        return row[0]
